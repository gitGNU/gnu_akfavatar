.\" Process this file with
.\" groff -man -Tutf8 lua-akfavatar-reference.de.man
.\"
.
.\" Macros .TQ .EX .EE taken from groff an-ext.tmac
.\" Copyright (C) 2007, 2009 Free Software Foundation, Inc.
.\" You may freely use, modify and/or distribute this file.
.
.\" Continuation line for .TP header.
.de TQ
.  br
.  ns
.  TP \\$1\" no doublequotes around argument!
..
.
.\" Start example.
.de EX
.  nr mE \\n(.f
.  nf
.  nh
.  ft CW
..
.
.
.\" End example.
.de EE
.  ft \\n(mE
.  fi
.  hy \\n(HY
..
.
.TH "Lua-AKFAvatar Referenz" 3 2015-01-07 AKFAvatar
.nh
.
.SH NAME
Lua-AKFAvatar Referenz \- AKFAvatar spezifische Funktionen f\[:u]r Lua
.
.SH BESCHREIBUNG
Dies ist eine Referenz f\[:u]r die Lua-Anbindung f\[:u]r AKFAvatar.
Sie beschreibt nicht die Sprache Lua.
Eine Referenz-Anleitung f\[:u]r die Sprache Lua findet man im Internet unter
.BR http://www.lua.org/manual/5.2/ ,
oder auf Deutsch unter
.BR http://lua.coders-online.net/ .
.PP
Keine Angst. Man muss nicht alles gleich verstehen oder gar lernen.
Man kann schon eine ganze Menge mit nur ganz wenigen Befehlen anfangen.
Einfach mal die Teile heraussuchen, die einen interessieren und damit
herumexperimentieren.
Es gibt viele Aspekte von Lua oder AKFAvatar, die man wahrscheinlich nie
ben\[:o]tigt.
.PP
.SS Datei-Formate
F\[:u]r Bilder werden die Formate
.BR XPM ", " XBM " und unkomprimiertes " BMP
auf jeden Fall unterst\[:u]tzt.
Weitere Formate werden unterst\[:u]tzt, wenn
.B SDL_image
und weitere Bibliotheken installiert sind.
.PP
F\[:u]r Audio werden die Formate
.BR AU " und " WAV
unterst\[:u]tzt.
Dateien k\[:o]nnen als PCM, \(*m-law oder A-law kodiert sein.
Es gibt auch ein Lua-Modul namens
.BR akfavatar-vorbis ,
welches Unterst\[:u]tzung f\[:u]r Ogg Vorbis Audio-Dateien hinzuf\[:u]gt.
.PP
.SS Grundfunktionalit\[:a]t
.TP
.B "local avt = require ""lua-akfavatar"""
Bevor man die AKFAvatar-Anbindung verwenden kann, muss man sie mit dieser
Anweisung erstmal laden.
\[:U]ber die Tabelle
.I avt
kann man dann die folgenden Funktionen abrufen.
.PP
.TP
.BI "avt.encoding(" encoding )
Legt die Text-Kodierung fest.
Wenn diese Funktion nicht verwendet wird, wird nur "ASCII" unterst\[:u]tzt.
.IP
Unterst\[:u]tzte Kodierungen:
.br
ASCII, UTF-8,
.br
ISO-8859-1, -2, -3, -4, -5, -7, -8, -9, -10, -11, -13, -14, -15, -16,
.br
KOI8-R, KOI8-U,
.br
IBM437 (PC-8), IBM850 (DOS-Latin-1),
.br
WINDOWS-1250, WINDOWS-1251, WINDOWS-1252
.br
SYSTEM
.PP
.TP
.BI "avt.get_encoding()"
Fragt die Text-Kodierung ab.
.PP
.TP
.BI "avt.title(" "Titel [,Kurzname]" )
.TQ
.BI "avt.set_title(" "Titel [,Kurzname]" )
Legt den Titel und den Kurznamen fest.
.PP
.TP
.BI "avt.start(" Modus )
Diese Funktion \[:o]ffnet das grafische Fenster oder wechselt in den Grafikmodus.
Falls es schon gestartet war, wird vieles zur\[:u]ck gesetzt.
.IP
.I Modus
ist entweder "auto", "window", "fullscreen", oder "fullscreen no switch".
Die Vorgabe ist "auto", die einen brauchbaren Modus verwendet, oder die
Einstellung unver\[:a]ndert l\[:a]sst, wenn es bereits gestartet war.
.IP
Wenn man die Kodierung, den Titel oder die Hintergrund-Farbe setzen will,
sollte man es machen, bevor man
.B avt.start()
aufruft.
Alle anderen Funktionen sollten erst danach verwendet werden.
.IP
.B Beispiel:
.EX
local avt = require "lua-akfavatar"
avt.encoding("ISO-8859-1")
avt.title("Mein Programm")
avt.set_background_color("sky blue")
avt.start()
avt.start_audio()
avt.avatar_image("default")
avt.tell("Hallo Welt!")
avt.wait_button()
.EE
.IP
Viele der folgenden Funktionen rufen automatisch
.B avt.start()
auf, wenn es noch nicht gestartet ist.
.PP
.TP
.BI "avt.started()"
Gibt
.I true
zur\[:u]ck, wenn AKFAvatar bereits gestartet ist, ansonsten gibt es
.I false
zur\[:u]ck.
.PP
.TP
.BI "avt.avatar_image(" Daten )
L\[:a]dt das Avatar-Bild von den
.IR Daten .
Die
.I Daten
k\[:o]nnen entweder "default" oder "none" sein,
oder ein String mit Bilddaten,
oder eine Tabelle mit Strings von XPM-Daten.
.PP
.TP
.BI "avt.avatar_image_file(" Dateiname )
L\[:a]dt das Avatar-Bild aus einer Datei.
Die Strings "default" oder "none" werden auch akzeptiert.
.PP
.TP
.BI "avt.set_avatar_name(" [Name] )
Setzt den Namen f\[:u]r den Avatar.
Dies muss nach dem Setzen des Bildes geschehen.
.PP
.TP
.BI "avt.set_avatar_mode(" Modus )
Legt den Avatar-Modus fest.
Der
.I Modus
ist entweder "say" (sagen), "think" (denken),
"header" (\[:U]berschrift) oder "footer" (Fu\[ss]zeile).
Der Avatar-Modus wird nur angewandt, wenn ein Avatar-Bild vorhanden ist.
.PP
.TP
.BI "avt.say(" ... )
.TQ
.BI "avt.write(" ... )
Schreibt Text in der Sprechblase.
.IP
Man kann Strings oder Zahlen verwenden.
Es funktioniert so \[:a]hnlich wie
.BR io.write() ,
aber es schreibt halt in die Sprechblase anstatt auf die
Standardausgabe.
.IP
.B Beispiel:
.EX
avt.say("Drei \[:A]pfel kosten ", 3 * Apfelpreis, " Euro.\en").
.EE
.PP
.TP
.BI "avt.print(" ... )
Schreibt Text in der Sprechblase.
Es funktioniert so \[:a]hnlich wie
.BR print ,
aber es schreibt halt in die Sprechblase anstatt auf die
Standardausgabe.
.IP
Der Unterschied zu
.B avt.say()
ist, dass die Werte in der Ausgabe durch Tabulatoren getrennt werden
und jeder Wert automatisch durch
.B tostring()
umgewandelt wird. Au\[ss]erdem wird die Zeile durch einen Zeilenumbruch
abgeschlossen.
.IP
Mann kann einfach den print-Befehl mit diesem Befehl ersetzen:
.BR "print = avt.print" .
(Das Skript `interactive_lua.lua' macht das so.)
.IP
Die Funktion
.B avt.say()
eignet sich besser f\[:u]r Programme, w\[:a]hrend diese Funktion besser f\[:u]r
die interaktive Verwendung und f\[:u]r's Debuggen geeignet ist.
.PP
.TP
.BI "avt.tell(" ... )
Schreibt Text in der Sprechblase, aber zuvor wird die Gr\[:o]\[ss]e der
Sprechblase angepasst, so dass der Text exakt reinpasst.
.IP
.B Beispiel:
.EX
avt.tell("Drei \[:A]pfel kosten ", 3 * Apfelpreis, " Euro.").
.EE
.IP
.B Achtung:
Diese Funktion hat noch immer Probleme mit Tabulatoren ("\et").
.PP
.TP
.BI "avt.newline()"
Beginne eine neue Zeile.
Das selbe, wie "\en" in
.BR avt.say() ,
aber schneller.
.PP
.TP
.BI "avt.set_text_delay(" [Verz\[:o]gerung] )
Aktiviere den Langsamschreibmodus.
Wenn
.I Verz\[:o]gerung
nicht angegeben ist, wird ein Vorgabewert verwendet.
Um den Langsamschreibmodus zu daktivieren, kann man den Wert
0 f\[:u]r die
.I Verz\[:o]gerung
verwenden.
.PP
.TP
.BI "avt.clear()"
L\[:o]scht das Text-Feld oder den Bereich.
Wenn noch keine Sprechblase angezeigt wird, wird diese hierdurch gezeichnet.
.PP
.TP
.BI "avt.flip_page()"
Wartet eine Weile und l\[:o]scht dann das Text-Feld.
Dasselbe wird durch "\ef" in
.B avt.say()
erreicht.
Siehe auch
.BR avt.set_flip_delay(delay) .
.PP
.TP
.BI "avt.move_in()"
Bewegt den Avatar herein.
.PP
.TP
.BI "avt.move_out()"
Bewegt den Avatar heraus.
.PP
.TP
.BI "avt.pager(" "Text [,Anfangszeile]" )
Zeigt einen l\[:a]ngeren Text in einer Textbetrachter-Anwendung.
.IP
Wenn die
.I Anfangszeile
angegeben und gr\[:o]\[ss]er als 1 ist, dann f\[:a]ngt er in der Zeile an.
Man kann von da aus aber immer noch zur\[:u]ck scrollen.
.PP
.TP
.BI "avt.wait(" [Sekunden] )
Wartet eine angegebene Zeit an Sekunden (kann ein Dezeimalbruch sein).
.IP
Wenn kein Wert angegeben ist, wartet er eine gewisse Zeit.
.PP
.TP
.BI "avt.ticks()"
Gibt einen Wert zur\[:u]ck, der jede Millisekunde erh\[:o]ht wird.
Das kann f\[:u]r Zeitsteuerung verwendet werden.
.PP
.TP
.BI "avt.show_avatar()"
Zeigt nur den Avatar ohne Sprechblase.
.PP
.TP
.BI "avt.bell()"
Gibt einen Ton aus, oder die Anzeige blinkt, wenn die Audio-Ausgabe nicht
initialisiert ist.
.PP
.TP
.BI "avt.flash()"
Die Anzeige blinkt einmal.
.PP
.TP
.BI "avt.show_image(" Daten )
Zeigt ein Bild von Bilddaten.
Die
.I Daten
k\[:o]nnen ein String mit Bilddaten sein,
oder eine Tabelle mit Strings von XPM-Daten.
Bei Erfolg wird
.IR true " zur\[:u]ckgegeben, oder " false " im Fehlerfall."
Bei Erfolg sollte entweder
.BR avt.wait() " oder " avt.wait_button() " oder " avt.get_key()
aufgerufen werden.
.PP
.TP
.BI "avt.show_image_file(" Dateiname )
L\[:a]dt ein Bild und zeigt es an.
Man kann mit
.I avt.search()
nach der Datei suchen lassen.
Bei Erfolg wird
.IR true " zur\[:u]ckgegeben, oder " false " im Fehlerfall."
Bei Erfolg sollte entweder
.BR avt.wait() " oder " avt.wait_button() " oder " avt.get_key()
aufgerufen werden.
.PP
.TP
.BI "avt.subprogram(" "function, [arg1, ...]" )
Ruft die Funktion als Unterprogramm auf.
.IP
Bei einer Beendigungsanfrage (dh. wenn man die <Esc>-Taste dr\[:u]ckt,
oder den Schlie\[ss]-Knopf des Fensters) kehrt es nur zum Hauptprogramm
zur\[:u]ck.
.IP
Bei Erfolg werden die Ergebnisse der Funktion zur\[:u]ckgegeben.
Bei einer Beendigungsanfrage wird nichts zur\[:u]ckgegeben.
.IP
Um ein Unterprogramm aus einer separaten Datei zu starten,
kann man
.B dofile
verwenden.
.EX
avt.subprogram(dofile, "unterprogramm.lua")
.EE
.PP
.TP
.BI "avt.optional(" modname )
L\[:a]dt ein Modul wie
.BR require ,
aber das Modul wird nicht ben\[:o]tigt, sondern es ist optional.
Das hei\[ss]t, es ist kein Fehler, wenn das Modul nicht geladen
werden kann.
.IP
Lua-AKFAvatar braucht nicht initialisiert sein, um diese
Funktion zu verwenden.
.PP
.SS Unicode
.TP
.BI "avt.say_unicode(" ... )
Schreibt Text in der Sprechblase mit spezieller Unterst\[:u]tzung f\[:u]r 
Unicode-Zeichen.
.IP
Dieser Befehl ist \[:a]hnlich wie
.BR avt.say() .
Strings werden auf die selbe Weise behandelt, abh\[:a]ngig von der eingestellten
Kodierung, aber Zahlen werden als Unicode-Codepoint interpretiert,
unabh\[:a]ngig von der eingestellten Kodierung.
.IP
Man kann das verwenden, um Zeichen zu verwenden, die in der eingestellten
Kodierung nicht zur Verf\[:u]gung stehen.
Manchmal ist es aber auch einfach nur einfacher.
.IP
.B Beispiel:
.EX
avt.say_unicode("Drei \[:A]pfel kosten ",
                tostring(3 * Apfelpreis), 0x20AC,
                ".\en").
.EE
.IP
Wie man hier sieht, muss man
.B tostring()
verwenden, wenn nummerische Angaben als solche angezeigt werden sollen.
Die Zahl
.I 0x20AC
hingegen repr\[:a]sentiert hier das Euro-W\[:a]hrungszeichen.
(Das `0x' leitet hexadezimale Zahlen ein.)
.IP
\[:U]brigens werden eine Gruppe von Unicode-Zahlen effektiver verarbeitet
als Strings.
.PP
.TP
.BI "avt.printable(" Codepoint )
\[:U]berpr\[:u]ft ob der angegebene
.I Codepoint
ein druckbares Unicode-Zeichen darstellt.
Es gibt
.I true
zur\[:u]ck, wenn das der Fall ist, oder
.IR false ,
wenn die Schriftart kein druckbares Zeichen daf\[:u]r hat
(es kann trotzdem ein unterst\[:u]tztes Steuerzeichen sein).
Diese Funktion ist unabh\[:a]ngig von der eingestellten Kodierung.
Sie kann zusammen mit
.B "avt.say_unicode(...)"
eingesetzt werden.
.PP
.TP
.BI "avt.combining(" Codepoint )
\[:U]berpr\[:u]ft ob der angegebene
.I Codepoint
ein kombinierendes Unicode-Zeichen darstellt
und als solches behandelt wird.
Es gibt
.I true
zur\[:u]ck, wenn das der Fall ist, oder
.IR false ,
wenn es nicht als solches unterst\[:u]tzt wird.
Das Ergebnis gilt nur f\[:u]r unterst\[:u]tzte Zeichen.
.PP
.TP
.BI "avt.detect_utf8(" "String [, Maximall\[:a]nge]" )
Pr\[:u]ft, of
.I String
g\[:u]ltiges UTF-8 (oder ASCII) ist.
.IP
Gepr\[:u]ft werden bis zu
.I Maximall\[:a]nge
Bytes, aber eine unvollst\[:a]ndige Sequenz wird noch abgeschlossen.
.PP
.TP
.BI "avt.toutf8(" "Codepoint [, ...]" )
Nimmt einen oder mehrere angegebene Unicode
.I Codepoints
und gibt diese als UTF-8 kodierten String zur\[:u]ck.
.PP
.TP
.BI "avt.utf8codepoints(" str )
Kann verwendet werden, um alle Unicode Codepoints
von einem UTF-8 kodierten String als Zahlen zu erhalten.
.IP
Beispiel:
.EX
  for c in avt.utf8codepoints(s) do
    avt.say_unicode(c)
    avt.say(string.format(" = U+%04X", c))
    avt.newline()
  end
.EE
.PP
.SS Gr\[:o]\[ss]en und Positionen
.TP
.BI "avt.set_balloon_size(" "[H\[:o]he] [, Breite]" )
Legt die Gr\[:o]\[ss]e der Sprechblase fest.
Wenn keine Werte angegeben sind, oder der Wert 0 verwendet wird,
wird die maximale Gr\[:o]\[ss]e verwendet.
.PP
.TP
.BI "avt.set_balloon_width(" [Breite] )
Legt die Breite der Sprechblase fest.
Ohne Wert, oder bei dem Wert 0 wird das Maximum verwendet.
.PP
.TP
.BI "avt.set_balloon_height(" [H\[:o]he] )
Legt die H\[:o]he der Sprechblase fest.
Ohne Wert, oder bei dem Wert 0 wird das Maximum verwendet.
.PP
.TP
.BI "avt.get_max_x()"
Ermittelt die maximale x-Postion des Cursors in der Sprechblase
(also die Breite).
.PP
.TP
.BI "avt.get_max_y()"
Ermittelt die maximale y-Postion des Cursors in der Sprechblase
(also die H\[:o]he).
.PP
.TP
.BI "avt.where_x()"
Ermittelt die x-Position des Cursors in der Sprechblase.
.PP
.TP
.BI "avt.where_y()"
Ermittelt die y-Position des Cursors in der Sprechblase.
.PP
.TP
.BI "avt.home_position()"
Gibt
.I true
zur\[:u]ck, wenn sich der Cursor auf der Startposition befindet,
oder
.IR false ,
wenn nicht.
(Das funktioniert auch f\[:u]r rechts-nach-links-Schreibung.)
.PP
.TP
.BI "avt.move_x(" x )
Setzt den Curser auf die angegebene
.IR x -Position.
.PP
.TP
.BI "avt.move_y("y )
Setzt den Curser auf die angegebene
.IR y -Position.
.PP
.TP
.BI "avt.move_xy(" "x, y" )
Setzt den Curser auf die angegebene
.IR x " und " y " Position."
.PP
.TP
.BI "avt.save_position()"
Speichert die aktuelle Cursor-Position.
.PP
.TP
.BI "avt.restore_position()"
Stellt eine zuvor gespeicherte Cursor-Postion wieder her.
.PP
.TP
.BI "avt.next_tab()"
Setzt den Cursor auf die n\[:a]chste Tabulator-Position.
.PP
.TP
.BI "avt.last_tab()"
Setzt den Cursor auf die vorhergehende Tabulator-Position.
.PP
.TP
.BI "avt.reset_tab_stops()"
Setzt die Tabulator-Positionen zur\[:u]ck auf jede achte Spalte.
.PP
.TP
.BI "avt.clear_tab_stops()"
L\[:o]scht alle Tabulator-Postionen
.PP
.TP
.BI "avt.set_tab(" "x, true" | false )
Setzt oder l\[:o]scht einen Tabulator an der angegebenen Position
.IR x .
.PP
.TP
.BI "avt.delete_lines(" "Zeile, Anzahl" )
L\[:o]scht die angegebene
.I Anzahl
an Zeilen, angefangen bei
.IR Zeile ;
der Rest wird hochgescrollt.
.PP
.TP
.BI "avt.insert_lines(" "Zeile, Anzahl" )
F\[:u]gt die angegebene
.I Anzahl
an Zeilen ein, angefangen bei
.IR Zeile ;
der Rest wird runtergescrollt.
.PP
.TP
.BI "avt.insert_spaces(" Anzahl )
F\[:u]gt
.I Anzahl
an Leerzeichen bei der jetzigen Postion ein.
Der Rest der Zeile wird weiter ger\[:u]ckt.
.PP
.TP
.BI "avt.delete_characters(" Anzahl )
L\[:o]scht
.I Anzahl
an Zeichen an der jetzigen Cursor-Position.
Der Rest der Zeile wird zur\[:u]ck ger\[:u]ckt.
.PP
.TP
.BI "avt.erase_characters(" Anzahl )
L\[:o]scht
.I Anzahl
an Zeichen.
Die Zeichen werden mit Leerzeichen \[:u]berschrieben.
.PP
.TP
.BI "avt.backspace()"
Geht ein Zeichen zur\[:u]ck.
Wenn der Cursor am Anfang der Zeile ist, passiert nichts.
.PP
.SS Text-Stil
.TP
.BI "avt.markup(" true | false )
Setzt den Auszeichnungs-Modus.
Im Auszeichnungs-Modus schaltet das Zeichen "_" das Unterstreichen
ein oder aus und das Zeichen "*" schaltet den Fettdruck-Modus
ein oder aus.
Die beiden Zeichen werden im Auszeichnungs-Modus niemals angezeigt!
.IP
Man kann immer die Overstrike-Technik verwenden, die keine Zeichen
reserviert.
Aber die ist schwerer zu benutzen.
.PP
.TP
.BI "avt.underlined(" true | false )
Schaltet das Unterstreichen ein oder aus.
.PP
.TP
.BI "avt.get_underlined()"
Gibt
.I true
zur\[:u]ck, wenn Unterstreichen eingeschaltet ist, oder
.IR false ,
wenn nicht.
.PP
.TP
.BI "avt.bold(" true | false )
Schaltet den Fettdruck an oder aus.
.PP
.TP
.BI "avt.get_bold()"
Gibt
.I true
zur\[:u]ck, wenn Fettdruck eingeschaltet ist, oder
.IR false ,
wenn nicht.
.PP
.TP
.BI "avt.inverse(" true | false )
Schaltet die invertierte Darstellung an oder aus.
.PP
.TP
.BI "avt.get_inverse()"
Gibt
.I true
zur\[:u]ck, wenn die invertierte Darstellung eingeschaltet ist, oder
.IR false ,
wenn nicht.
.PP
.TP
.BI "avt.normal_text()"
Setzt normale Einstellungen f\[:u]r Text zur\[:u]ck.
.PP
.SS Farben
.TP
.BI "avt.set_background_color(" Farbe )
Setzt die Hintergrundfarbe f\[:u]r den Bildschirm.
.IP
Farben k\[:o]nnen entweder \[:u]ber ihren englischen Namen angegeben werden,
oder als RGB-Angabe 6 hexadezimalen Ziffern.
.IP
.B Beispiele:
.EX
avt.set_background_color("sky blue")
avt.set_background_color(0x8B4513)
avt.set_background_color("#8B4513") --> nicht empfohlen
avt.set_background_color("#555") --> nicht empfohlen
.EE
.PP
.TP
.BI "avt.set_balloon_color(" Farbe )
Setzt die Farbe der Sprechblase.
.PP
.TP
.BI "avt.set_text_color(" Farbe )
Setzt die Farbe des Textes.
.PP
.TP
.BI "avt.set_text_background_color(" Farbe )
Setzt die Hintergrundfarbe des Textes.
.PP
.TP
.BI "avt.set_text_background_ballooncolor()"
Setzt die Hintergrundfarbe des Textes auf die Farbe der Sprechblase.
.PP
.TP
.BI "avt.set_bitmap_color(" Farbe )
Setzt die Vordergrundfarbe f\[:u]r Bitmaps (einfarbige Grafiken).
Der Hintergrund ist immer transparent.
.PP
.TP
.BI "avt.get_color(" Farbnummer )
Hole die Farbdefinition f\[:u]r die angegebene Farbnummer.
.IP
AKFAvatar hat eine interne Palette mit englischsprachigen
Farbnamen, die man verwenden kann.
Mit dieser Funktion kann man diese Liste durchgehen.
Sie gibt den Namen und die RGB-Definition als String zur\[:u]ck,
oder es gibt nichts zur\[:u]ck, wenn die Farbnummer nicht existiert.
.PP
.TP
.BI "avt.colors()"
Iterator f\[:u]r interne Farbnamen.
.IP
AKFAvatar hat eine interne Palette mit englischsprachigen
Farbnamen, die man verwenden kann.
Mit dieser Funktion kann man diese Liste mit einer
allgemeinen
.BR for "-Schleife durchgehen."
.IP
.EX
require "lua-akfavatar"
for nr, name, rgb in avt.colors() do
  avt.normal_text()
  avt.newline()
  avt.say(string.format("%3d) %5s, %-25s", nr, rgb, name))
  avt.set_text_background_color(name) -- name oder rgb
  avt.clear_eol()
  avt.wait(0.7)
end
avt.wait_button()
.EE
.IP
Wenn man den
.IR rgb "-Wert"
nicht ben\[:o]tigt, kann man die Variable weglassen.
.PP
.SS Interaktion
.TP
.BI "avt.wait_button()"
Wartet bis ein Knopf gedr\[:u]ckt wird.
.PP
.TP
.BI "avt.decide()"
Fragt den Benutzer nach einer positiven oder negativen Antwort.
Gibt etweder
.IR true " oder " false " zur\[:u]ck."
.PP
.TP
.BI "avt.ask(" [Frage] )
Zeigt die
.IR Frage ,
falls angegeben, und wartet bis der Benutzer etwas eingibt.
Gibt das Eingegebene als String zur\[:u]ck.
.IP
Das folgende Beispiel zeigt, wie man die Eingabe einer Zahl erzwingt:
.IP
.EX
require "lua-akfavatar"
avt.save_position()
repeat
  avt.restore_position()
  Zahl = tonumber(avt.ask("Gib eine Zahl ein: "))
until Zahl
avt.say("Die Zahl ist ", Zahl)
avt.wait_button()
.EE
.PP
.TP
.BI "avt.file_selection(" [Filter] )
Startet einen Dateiauswahl-Dialog in der Sprechblase.
Am Anfang zeigt er das aktuelle Arbeitsverzeichnis an.
Wenn ein Verzeichnis ausgew\[:a]hlt wird, wird das zum Arbeitsverzeichnis.
Wenn eine Datei ausgew\[:a]hlt wird, wird der Dateiname zur\[:u]ckgegeben
(die sich dann im dann aktuellen Arbeitsverzeichnis befindet),
oder im Fehlerfall wird 
.I nil
zur\[:u]ckgegeben.
.IP
Der
.IR Filter ,
falls angegeben, sollte eine Funktion sein.
Sie bekommt einen Dateinamen als Parameter.
Die Datei befindet sich immer im aktuellen Arbeitsverzeichnis.
Wenn die Filter-Funktion
.IR false " oder " nil
oder nichts zur\[:u]ckgibt, dann wird die Datei nicht angezeigt,
ansonsten wird sie angezeigt.
.IP
.B Beispiel:
.EX
 Textdatei = avt.file_selection(
    function(n)
      return string.find(n,"%.te?xt$")
    end)
.EE
.IP
Nat\[:u]rlich kann f\[:u]r
.I Filter
auch einfach der Name einer zuvor definierten Funktion
angegeben werden.
.PP
.TP
.BI "avt.color_selection()"
Startet einen Farbauswahl-Dialog in der Sprechblase.
Es werden zwei Strings zur\[:u]ckgegeben: erstens der englische Name
f\[:u]r die Farbe und zweitens die hexadezimale RGB-Definition.
Beide Werte k\[:o]nnen f\[:u]r die Farbauswahl verwendet werden.
.PP
.TP
.BI "avt.get_key()"
Wartet auf einen Tastendruck und gibt den Unicode-Codepoint des
Zeichens zur\[:u]ck.
F\[:u]r einige Funktionstasten werden Werte aus einem Unicode-Bereich
f\[:u]r den privaten Gebrauch zur\[:u]ckgegeben.
.PP
.TP
.BI "avt.key_pressed()"
Pr\[:u]ft, ob eine Taste gedr\[:u]ckt wurde.
Um den Tasten-Code abzuholen kann man
.B avt.get_key()
verwenden.
.PP
.TP
.BI "avt.clear_keys()"
L\[:o]scht den Tastatur-Buffer
.PP
.TP
.BI "avt.push_key(" Codepoint )
Simuliert einen Tastendruck
.PP
.TP
.BI "avt.navigate(" buttons )
Zeigt eine Navigationsleiste mit den angegebenen Kn\[:o]pfen.
.IP
F\[:u]r die Kn\[:o]pfe kann man in einem String die folgenden Zeichen
verwenden:
.IP
.RS
.IP "l:"
links
.IP "r:"
rechts (abspielen)
.IP "d:"
runter
.IP "u:"
hoch
.IP "x:"
abbrechen
.IP "f:"
(schnell)vorw\[:a]rts
.IP "b:"
(schnell)r\[:u]ckw\[:a]rts
.IP "p:"
Pause
.IP "s:"
Stop
.IP "e:"
Auswurf
.IP "*:"
Kreis (Aufnahme)
.IP "+:"
Plus (hinzuf\[:u]gen)
.IP "-:"
Minus (entfernen)
.IP "?:"
Hilfe
.IP "' ':"
Platzhalter (kein Knopf)
.RE
.IP
Eine Taste mit einem dieser Zeichen zu dr\[:u]cken w\[:a]hlt diesen aus.
F\[:u]r die Richtungen kann man auch die Pfeiltasten verwenden.
Die <Pause>-Taste gibt "p" zur\[:u]ck.
Die <Hilfe>-Taste oder <F1> geben "?" zur\[:u]ck.
.IP
Es wird das entsprechende Zeichen zur\[:u]ckgegeben oder eine Zahl.
.IP
Wenn eine Audio-Ausgabe endet, w\[:a]hrend diese Funktion aktiv ist, wird
automatisch entweder "f" (vorw\[:a]rts) oder "s" (Stop) ausgew\[:a]hlt.
Falls beides vorhanden ist, hat "f" Vorrang.
.PP
.TP
.BI "avt.menu(" Men\[:u]punkte )
.TQ
.BI "avt.long_menu(" Men\[:u]punkte )
Zeigt ein Men\[:u] mit den angegebenen 
.IR Men\[:u]punkte "n."
Die
.I Men\[:u]punkte
k\[:o]nnen zum Einen ein Array mit Strings sein.
Dann wird die Nummer (Position) des ausgew\[:a]hlten Men\[:u]punktes
zur\[:u]ckgegeben.
.IP
Oder
.I Men\[:u]punkte
k\[:o]nnen ein Array mit weiteren Arrays sein.
Die inneren Arrays m\[:u]ssen dann mit einem String anfangen, gefolgt von
einem oder mehreren Egebnissen.
Die Ergebnisse k\[:o]nnen jeder beliebige Lua-Typ sein, einschlie\[ss]lich
Funktionen.
.IP
Das Men\[:u] f\[:a]ngt in der Zeile der aktuellen Cursor-Position an.
Dadurch kann man eine \[:U]berschrift vor das Men\[:u] setzen.
.IP
.EX
avt.clear()
avt.say("Bitte das Liebligsessen ausw\[:a]hlen:\en")
local Menuepunkt = avt.long_menu {
  "Chicken",
  "Chips",
  "Pizza",
  "Spinach"}
.EE
.PP
.TP
.BI "avt.choice(" "Anfanszeile, Eintr\[:a]ge [, Taste] [, zur\[:u]ck] [, vorw\[:a]rts]" )
Diese Funktion kann f\[:u]r Men\[:u]s verwendet werden.
Es ist eine grundlegendere Funktion, als
.BR avt.menu() .
Es gibt die Nummer den ausgew\[:a]hlten Men\[:u]punktes zur\[:u]ck.
.IP
.RS
.TP
.IR Anfangszeile :
die Zeile, in der die Auswahl beginnt
.TP
.IR Eintr\[:a]ge :
Anzahl der Eintr\[:a]ge (Zeilen)
.TP
.IR Taste :
Anfangstaste, wie "1" oder "a", 0 f\[:u]r keine Tastenunterst\[:u]tzung
.TP
.IR zur\[:u]ck :
auf
.I true
zu setzen, wenn der erste Eintrag eine zur\[:u]ck-Funktion hat
.TP
.IR vorw\[:a]rts :
auf
.I true
zu setzen, wenn der letzte Eintrag eine weiter-Funktion hat
.RE
.PP
.SS Audio-Ausgabe
.TP
.BI "avt.start_audio()"
Startet das Audio-Untersystem.
.IP
Bei Erfolg gibt es
.I true
zur\[:u]ck, im Fehlerfall gibt es
.I nil
und eine Fehlermeldung zur\[:u]ck.
.PP
.TP
.BI "avt.load_audio_file(" "[Dateiname [,Abspielmodus]]" )
.TQ
.BI "avt.load_base_audio_file(" "[Dateiname [,Abspielmodus]]" )
Liest Audio-Daten von einer Datei ein.
Man kann mit
.B avt.search()
nach der Datei suchen lassen.
.IP
Lua-Module k\[:o]nnen Unterst\[:u]tzung f\[:u]r weitere Audio-Formate zu
.B "avt.load_audio_file()"
hinzuf\[:u]gen.
(Das tut zum Beispiel das Modul
.BR akfavatar-vorbis ).
.IP
Wenn kein
.I Dateiname
angegeben ist, oder der
.IR Dateiname " ist " nil
oder ein leerer String, wird ein Audio-Element mit Stille zur\[:u]ckgegeben,
das hei\[ss]t, man kann die Methoden aufrufen, aber es wird kein Klang ausgegeben.
.IP
.I Abspielmodus
kann entweder "load", "play" oder "loop" sein.
.IP
Bei Fehlern wird
.I nil
und eine Fehlermelung zur\[:u]ckgegeben.
(Anmerkung: in Version 0.19.0 wurde dann auch eine Stille zur\[:u]ckgegeben.)
.PP
.TP
.BI "avt.load_audio_stream(" "Datei [,Gr\[:o]\[ss]e [,Abspielmodus]]" )
.TQ
.BI "avt.load_base_audio_stream(" "Datei [,Gr\[:o]\[ss]e [,Abspielmodus]]" )
Liest Audio-Daten von einer ge\[:o]ffneten Datei.
.IP
Lua-Module k\[:o]nnen Unterst\[:u]tzung f\[:u]r weitere Audio-Formate zu
.B "avt.load_audio_stream()"
hinzuf\[:u]gen.
(Das tut zum Beispiel das Modul
.BR akfavatar-vorbis ).
.IP
Wenn keine Gr\[:o]\[ss]e angegeben ist, wird davon ausgegangen, 
dass die Audio-Daten bis zum Ende der Datei gehen.
.IP
.I Abspielmodus
kann entweder "load", "play" oder "loop" sein.
.IP
Bei Fehlern wird
.I nil
und eine Fehlermelung zur\[:u]ckgegeben.
.PP
.TP
.BI "avt.load_audio(" "[Audiodaten [,Abspielmodus]]" )
.TQ
.BI "avt.load_base_audio(" "[Audiodaten [,Abspielmodus]]" )
Liest Audiodaten aus einem String.
Ansonsten das selbe, wie
.BR avt.load_audio_file() .
.IP
Lua-Module k\[:o]nnen Unterst\[:u]tzung f\[:u]r weitere Audio-Formate zu
.B "avt.load_audio()"
hinzuf\[:u]gen.
(Das tut zum Beispiel das Modul
.BR akfavatar-vorbis ).
.IP
Wenn keine
.I Audiodaten
angegeben sind, oder
.IR Audiodaten " ist " nil
oder ein leerer String, wird ein Audio-Element mit Stille zur\[:u]ckgegeben,
das hei\[ss]t, man kann die Methoden aufrufen, aber es wird kein Klang ausgegeben.
.IP
.I Abspielmodus
kann entweder "load", "play" oder "loop" sein.
.IP
Bei Fehlern wird
.I nil
und eine Fehlermelung zur\[:u]ckgegeben.
(Anmerkung: in Version 0.19.0 wurde dann auch eine Stille zur\[:u]ckgegeben.)
.PP
.TP
.B avt.silent()
Gibt ein stilles Audio-Element zur\[:u]ck,
das hei\[ss]t, man kann die Methoden aufrufen, aber es wird kein Klang ausgegeben.
.IP
.B Beispiel:
.EX
audio = avt.load_audio_file(Dateiname) or avt.silent()
.EE
.IP
In diesem Beispiel bekommt man einen stillen Klang, wenn die Datei nicht
gelesen werden konnte.
.PP
.TP
.B avt.alert()
Gibt ein Pseudo-Audio-Element zur\[:u]ck, welches
.B avt.bell()
aufruft, wenn man es abspielt.
.PP
.TP
.BI "avt.frequency(" "Frequenz [, Lautst\[:a]rke]" )
Erzeugt ein Audio-Element mit einem kurzen Ton
in der angegebenen
.I Frequenz
(in Hertz (Hz), auf eine Ganzzahl gerundet)
mit der angegebenen
.I Lautst\[:a]rke
(0-100, Vorgabe 75).
Dieses Audio-Element kann problemlos als Schleife
wiedergegeben werden.
.IP
.B Beispiel:
.EX
avt.frequency(440):loop()
.EE
.PP
.TP
.BI "avt.audio_playing(" [Audiodaten] )
\[:U]berpr\[:u]ft, ob Audiodaten gerade abgespielt werden.
Wenn
.I Audiodaten
angegeben ist und nicht
.I nil
ist, dann wird \[:u]berpr\[:u]ft, ob die angegebenen Audiodaten abgespielt werden.
Das kann man \[:u]brigens auch mit
.IB audio ":playing()"
\[:u]berpr\[:u]fen.
.PP
.TP
.BI "avt.wait_audio_end()"
Wartet, bis die Audio-Ausgabe beendet ist.
.IP
Dadurch wird auch eine Audio-Schleife beendet, aber es spielt halt
noch bis zum Ende des aktuellen Klanges.
.PP
.TP
.BI "avt.stop_audio()"
Stoppt die Audio-Ausgabe sofort.
.PP
.TP
.BI "avt.pause_audio(" true | false )
Die Audio-Ausgabe wird
.RI "pausiert (" true ") oder weiter gespielt (" false ")"
.PP
.TP
.IB audio ":play()"
.TQ
.IB audio "()"
Spielt die Audiodaten
.I audio
ab.
.IP
Es kann nur ein Klang gleichzeitig abgespielt werden.
Wenn man einen anderen Klang abspielt, wird der vorherige
dadurch abgebrochen.
Man kann
.B avt.wait_audio_end()
verwenden, um Kl\[:a]nge nacheinander abzuspielen.
.IP
Man kann den Klang auch abspielen, indem man die Audio-Variable
wie eine Funktion aufruft.
.IP
.EX
abspielen = function (Dateiname)
  local Klang = avt.load_audio_file(avt.search(Dateiname))
  if Klang then Klang:play() end
end
.EE
.PP
.TP
.IB audio ":loop()"
Spielt die Audiodaten
.I audio
in einer Schleife ab.
.IP
Das ist zum Beispiel f\[:u]r eine kurze Musik-Sequenz n\[:u]tzlich.
.IP
Man kann die Audio-Schleife mit
.BR avt.wait_audio_end() " oder " avt.stop_audio()
beenden.
.PP
.TP
.IB audio ":playing()"
\[:U]berpr\[:u]ft, ob diese
.IR audio -Daten
gerade abgespielt werden.
Die Audiodaten
.I audio
m\[:u]ssen mit
.BR avt.load_audio_file() " oder " avt.load_audio_string()
geladen worden sein.
.IP
Diese Funktion ist identisch mit 
.BR "avt.audio_playing(audio)" .
.PP
.TP
.IB audio ":free()"
Gibt die
.IR audio -Daten
frei.
Falls diese
.IR audio -Daten
gerade abgespielt werden, wird die Audio-Ausgabe abgebrochen.
.IP
Audiodaten werden auch vom Garbage Collector freigegeben.
.PP
.TP
.BI "avt.set_audio_end_key (" Taste )
Definiere eine Taste, die automatisch gedr\[:u]ckt werden soll, wenn
die Audio-Ausgabe endet.
Die
.I Taste
sollte als Zahl f\[:u]r den Unicode-Codepoint angegeben werden.
Durch den Wert
.I 0
kann man das wieder abschalten.
.IP
Die Funktion gibt den voher gesetzten Wert zur\[:u]ck.
.PP
.TP
.BI "avt.quit_audio()"
Das Audio-Untersystem beenden.
.IP
Das ist bei normalen Programmen nicht n\[:o]tig.
Diese Funktion sollte nur verwendet werden, wenn man wei\[ss], was man tut.
.PP
.SS Dateisystem
.TP
.BI "avt.dirsep"
Diese Variable enth\[:a]lt das Verzeichnis-Trennzeichen des Systems;
entweder "/" oder "\e".
.PP
.TP
.BI "avt.datapath"
Diese Variable enth\[:a]lt den Standardsuchpfad f\[:u]r die Funktion
.B avt.search()
(siehe unten).
Verzeichnisse werden durch Semikola getrennt.
Es gibt keine Muster, wie in den Pfaden f\[:u]r Lua-Module,
sondern es werden nur Verzeichnisse angegeben.
Diese Variable wird entweder durch die Umgebungsvariable
.I AVTDATAPATH
initialisiert,
oder sie bekommt eine systemspezifische Vorgabeeinstellung.
.PP
.TP
.BI "avt.search(" "Dateiname [,Pfad]" )
Sucht eine Datei mit dem angegebenen
.IR Dateiname n
im angegebenen
.IR Pfad .
Wenn kein
.I Pfad
angegeben ist, wird die Variable
.I avt.datapath
verwendet.
.IP
Wenn die Datei gefunden wurde, wird der vollst\[:a]ndige Pfad der
Datei zur\[:u]ckgegeben.
Wenn die Datei nicht gefunden wurde, wird
.I nil
und eine Fehlermeldung zur\[:u]ckgegeben.
.PP
.TP
.BI "avt.get_directory()"
.TQ
.BI "avt.getcwd()"
Gibt das aktuelle Arbeitsverzeichnis zur\[:u]ck.
Im Fehlerfall wird
.I nil
und eine Fehlermeldung zur\[:u]ckgegeben.
.PP
.TP
.BI "avt.set_directory(" directory )
.TQ
.BI "avt.chdir(" Verzeichnis )
Setzt das Arbeitsverzeichnis auf
.IR Verzeichnis .
.RI "Wenn " Verzeichnis " " nil
ist, ein Leerstring oder nicht angegeben ist, wird nichts ausgef\[:u]hrt.
.IP
Gibt bei Erfolg
.I true
zur\[:u]ck oder bei einem Fehler
.I nil
und eine Fehlermeldung.
.IP
.B Beispiel:
.EX
avt.set_directory(os.getenv("HOME") or os.getenv("USERPROFILE"))
.EE
.PP
.TP
.BI "avt.directory_entries(" [Verzeichnis] )
Hole eine Liste von Verzeichniseintr\[:a]gen vom angegebenen
.I Verzeichnis
oder dem aktuellen Arbeitsverzeichnis, wenn keins angegeben ist.
.IP
Bei Erfolg gibt es ein Array mit den Verzeichniseintr\[:a]gen zur\[:u]ck
und die Anzahl der Eintr\[:a]ge.
Im Fehlerfall wird
.I nil
und eine Fehlermeldung zur\[:u]ckgegeben.
.IP
Die Liste enth\[:a]lt sowohl normale Dateinamen, einschlie\[ss]lich
verstecken Dateien, Unterverzeichnisse und andere Arten von Eintr\[:a]gen.
Die Eintr\[:a]ge "." oder ".." sind nicht mit drin.
.IP
Achtung: Die Namen sind in einer systemspezifischen Kodierung.
Um die Namen anzeigen zu k\[:o]nnen, muss man entweder die Kodierung
der Anzeige mit
.B "avt.encoding(""SYSTEM"")"
\[:a]ndern, oder die Namen wie folgt konvertieren:
.BR "avt.say(avt.recode(name, ""SYSTEM""))" .
.PP
.TP
.BI "avt.entry_type(" Eintrag )
Ermittle die Art eines Verzeichniseintrags und seine Gr\[:o]\[ss]e.
.IP
Bei Erfolg gibt es die Art des Verzeichniseintrags als String
zur\[:u]ck und die Gr\[:o]\[ss]e als Zahl.
Die Art ist entweder "file", "directory", "character device", 
"block device", "fifo", "socket" oder "unknown".
.IP
Im Fehlerfall wird
.I nil
und eine Fehlermeldung zur\[:u]ckgegeben.
.IP
Symbolische Links werden ausgewertet.
Das bedeutet, man bekommt die Art des resultierenden Eintrags.
Kaputte Links werden wie nicht existierende Eintr\[:a]ge behandelt.
.PP
.SS Verschiedenes
.TP
.BI "avt.language"
Diese Variable enth\[:a]lt einen Sprachcode f\[:u]r Meldungen.
Es sollte sich um eine Kennung mit zwei Buchstaben gem\[:a]\[ss]
ISO 639-1 handeln.
Wenn die Sprache nicht ermittelt werden konnte, ist die Variable
nicht gesetzt.
.PP
.TP
.BI "avt.translate(" Text )
\[:U]bersetzt den
.IR Text ,
falls m\[:o]glich.
.IP
Wie man \[:U]bersetzungen angeben kann, steht im Abschnitt
.BR \[:U]bersetzungen .
.PP
.TP
.BI "avt.recode(" "String, Quellkodierung [,Zielkodierung]" )
Konvertiert den angegebenen
.IR String ,
der in
.I Quellkodierung
kodiert ist, in einen String der in
.I Zielkodierung
kodiert ist.
Wenn nur eine Kodierung angegeben ist, kovertiert es in die 
aktuell gesetzte Kodierung.
Falls man von der aktuellen Kodierung in etwas anderes kovertieren will,
kann man
.IR nil " f\[:u]r die " Quellkodierung
angeben.
.IP
Um in die oder aus der Standardkodierung des Systems umzukodieren
(zum Beispiel f\[:u]r Dateinamen), kann man einen leeren String
.RI ( """""" ") oder " """SYSTEM"""
angeben.
.IP
Gibt den kodierten String zur\[:u]ck, oder
.IR nil ,
bei schweren Fehlern.
.IP
.B Achtung:
Nach UTF-8 zu konvertieren ist immer m\[:o]glich.
Nach anderen Kodierungen zu konvertieren, kann jedoch fehlschlagen.
Zeichen, die nicht konvertiert werden k\[:o]nnen,
werden durch das Steuerzeichen
.IR "SUB " ( """\ex1A""" )
ersetzt.
Um sicher zu stellen, dass die Konvertierung verlustfrei ablief,
kann man \[:u]berpr\[:u]fen, dass dieses Zeichen im Ausgabestring
nicht vorkommt.
.PP
.TP
.BI "avt.right_to_left(" true | false )
Aktiviert, oder deaktiviert den rechts-nach-links-Schreibmodus.
.IP
.B Achtung:
Dies ist noch experimentell und funktioniert nur eingeschr\[:a]nkt.
.PP
.TP
.BI "avt.set_flip_page_delay(" [delay] )
Setzt eine Verz\[:o]gerung f\[:u]r
.B avt.flip_page()
oder "\ef".
Ohne Angabe eines Wertes wird auf die Vorgabe zur\[:u]ckgesetzt.
Der Wert 0 schaltet die Verz\[:o]gerung ganz aus.
.PP
.TP
.BI "avt.activate_cursor(" true | false )
Legt fest, ob der Cursor angezeigt wird, oder nicht.
.PP
.TP
.BI "avt.clear_screen()"
L\[:o]scht den gesamten Bildschirm, bzw. das Fenster
(nicht nur die Sprechblase!).
.PP
.TP
.BI "avt.clear_down()"
L\[:o]scht von der Cursor-Postition nach unten im Anzeigebereich.
Wenn noch keine Sprechblase angezeigt wird, wird sie gezeichnet.
.PP
.TP
.BI "avt.clear_eol()"
L\[:o]scht das Ende der Zeile (abh\[:a]ngig von der Text-Richtung).
.PP
.TP
.BI "avt.clear_bol()"
L\[:o]scht den Anfang der Zeile (abh\[:a]ngig von der Text-Richtung).
.PP
.TP
.BI "avt.clear_line()"
L\[:o]scht die Zeile.
.PP
.TP
.BI "avt.clear_up()"
L\[:o]scht von der Cursor-Postition nach oben im Anzeigebereich.
Wenn noch keine Sprechblase angezeigt wird, wird sie gezeichnet.
.PP
.TP
.BI "avt.reserve_single_keys(" true | false )
Reserviert Einzeltasten, wie <ESC> oder <F11>.
.PP
.TP
.BI "avt.switch_mode(" mode )
\[:A]ndert den Fenster-Modus.
Man kann es entwerder auf
.IR """window""" ", oder " """fullscreen"""
setzen.
.IP
(Die Modi 
.IR """auto""" " und  " """fullscreen no switch"""
funktionieren hiermit nicht.)
.PP
.TP
.BI "avt.get_mode()"
Gibt den Fenster-Modus zur\[:u]ck
(siehe
.BR "avt.switch_mode (mode)" ).
.PP
.TP
.BI "avt.toggle_fullscreen()"
Schaltet den Vollbild-Modus ein oder aus.
.PP
.TP
.BI "avt.update()"
Aktualisiert alles und reagiert auf Ereignisse.
Dies sollte innehalb von Schleifen ausgef\[:u]hrt werden, w\[:a]hrend das
Programm mit anderem besch\[:a]ftigt ist.
.PP
.TP
.BI "avt.credits(" "text, centered" )
Zeigt einen Abspann.
.IP
Wenn der zweite Parameter
.I true
ist, wird jede Zeile zentriert.
.PP
.TP
.BI "avt.viewport(" "x, y, width, height" )
Setzt einen Anzeigebereich (einen Unterbereich des Textbereiches).
Die obere linke Ecke hat die Koordinaten 1, 1.
.PP
.TP
.BI "avt.set_scroll_mode(" Modus )
Setzt den Rollmodus, dh. wie er reagiert, wenn man hinter der
letzten Zeile weiter schreibt.
Der
.I Modus
ist entweder -1 f\[:u]r "nichts tun" oder 0 f\[:u]r "Seite umbl\[:a]ttern"
oder 1 f\[:u]r "hochrollen".
.PP
.TP
.BI "avt.get_scroll_mode()"
Gibt den Rollmodus zur\[:u]ck
(siehe
.BR "avt.set_scroll_mode()" ")."
.PP
.TP
.BI "avt.newline_mode(" true | false )
Wenn der Neue-Zeile-Modus aktiviert ist (Vorgabe), dann setzt ein
Zeilenvorschub-Zeichen den Cursor an den Anfang einer neuen Zeile.
Wenn er aus ist, geht der Cursor in die n\[:a]chste Zeile, bleibt aber
in der selben horizontalen Position.
.PP
.TP
.BI "avt.set_auto_margin(" true | false )
Setzt den Modus f\[:u]r automatischen Zeilenumbruch, dh. ob
eine neue Zeile angefangen werden soll, wenn der Text nicht
in eine Zeile passt.
.PP
.TP
.BI "avt.get_auto_margin()"
Gibt den Modus f\[:u]r automatischen Zeilenumbruch zur\[:u]ck.
.PP
.TP
.BI "avt.set_origin_mode(" true | false )
Setzt den Ursprungs-Modus.
Wenn der Ursprungs-Modus eingeschaltet ist, sind die Koordinaten
1, 1 immer oben links in der Sprechblase, auch dann, wenn der
Anzeigebereich (viewport) nicht dort beginnt.
Wenn der Ursprungs-Modus ausgeschaltet ist, sind die Koordinaten
1, 1 oben links im Anzeigebereich (viewport).
.PP
.TP
.BI "avt.get_origin_mode()"
Gibt den Ursprings-Modus zur\[:u]ck
(siehe
.BR "avt.set_origin_mode" ")."
.PP
.TP
.BI "avt.set_mouse_visible(" true | false )
Legt fest, ob der Mauszeiger sichtbar sein soll, oder nicht.
.IP
.B Anmerkung:
Wenn die Anwendung in einem Fenster l\[:a]uft, gilt das nur,
wenn sich der Mauszeiger innerhalb des Fensters befindet.
.PP
.TP
.BI "avt.lock_updates(" true | false )
Blockiert Aktualisierungen innerhalb der Sprechblase.
Das kann man verwenden um die Geschwindigkeit zu erh\[:o]hen.
.PP
.TP
.BI "avt.version()"
Gibt die Version von AKFAvatar als String zur\[:u]ck.
.PP
.TP
.BI "avt.copyright()"
Gibt die Copyright-Meldung f\[:u]r AKFAvatar als String zur\[:u]ck.
.PP
.TP
.BI "avt.license()"
Gibt die Lizenz-Meldung f\[:u]r AKFAvatar als String zur\[:u]ck.
.PP
.TP
.BI "avt.quit()"
Beendet das AKFAvatar Untersystem (schlie\[ss]t das Fenster).
Das Audio-Untersystem wird ebenfalls beendet.
.IP
Diese Funktion wird nicht in normalen Programmen ben\[:o]tigt.
Man sollte sie nur verwenden, wenn das Programm ohne sichbares
Fenster weiter laufen soll.
.PP
.TP
.BI "avt.launch(" "Programm [,Argumente ...]" )
Beendet AKFAvatar und f\[:u]hrt das angegebene 
.I Programm
aus.
Diese Funktion kehrt niemals zur\[:u]ck.
Das Programm wird auf jeden Fall beendet.
.PP
.SH \[:U]bersetzungen
Um \[:U]bersetzungen f\[:u]r Lua-AKFAvatar Skripte zu schreiben, muss man erstmal die
Variable
.B avt.translations
definieren.
Es handelt sich dabei um eine verschachtelte Tabelle.
Nun, die ist schwer zu beschreiben, aber das Beispiel-Skript weiter unten
sollte es verst\[:a]ndlich machen.
.PP
Die zu verwendende Sprache wird durch die Variable
.B avt.language
festgelegt.
Diese Variable sollte von Lua-AKFAvatar automatisch initialisiert worden sein,
sie kann aber auch im Skript ge\[:a]ndert werden.
Sie enth\[:a]lt eine Sprach-Kennung mit zwei Buchstaben gem\[:a]\[ss] ISO 639-1.
.PP
Die Funktion
.BI avt.translate( Text )
gibt dann den \[:u]bersetzten Text zur\[:u]ck.
Falls keine \[:U]bersetzung zur Verf\[:u]gung steht, wird der Text unver\[:a]ndert zur\[:u]ck
gegeben.
.PP
Es ist ratsam, einen lokalen Alias namens
.BR L " f\[:u]r " avt.translate
anzulegen:
.EX
  local L = avt.translate
.EE
Dann kann man einfach eine String-Konstante damit einleiten.
.PP
.BR Beispiel :
.EX
local avt = require "lua-akfavatar"

avt.encoding("UTF-8")

avt.translations = {

  ["Hello world!"] = {
    es="\[r!]Hola mundo!",
    fr="Bonjour le monde!",
    de="Hallo Welt!",
    sv="Hej V\[:a]rlden!",
    },

  ["That's live!"] = {
    de="So ist das Leben!",
    fr="C'est la vie!" },
}

local L = avt.translate

-- avt.language = "de"

avt.start()
avt.avatar_image("default")
avt.tell(L"Hello world!", "\en", L"That's live!");
avt.wait_button ()
.EE
.PP
.BR Tipps :
.IP \(en 2
Obwohl es nicht notwendig ist, sollte man Englisch als Ausgangssprache
verwenden.
.IP \(en
Wenn man Text mit Variablen dazwischen hat, ist es kein guter Ansatz, den Text
in Teile aufzuteilen.
Es ist besser einen Format-String f\[:u]r
.B string.format()
zu definieren.
.IP \(en
Der \[:u]bersetzbare String muss exakt \[:u]bereinstimmen.
Bitte daran denken, wenn man die Strings im Programm ab\[:a]ndert,
dass man dann auch die \[:U]bersetzungstabelle anpassen muss!
.IP \(en
Der String kann auch ein Dateiname f\[:u]r eine Textdatei oder eine
Sprachaufnahme sein.
.PP
\[:U]brigens, diese Implementierung wurde von GNU gettext inspiriert.
.PP
.SH "SIEHE AUCH"
.BR lua-akfavatar (1)
.BR lua (1)
.BR akfavatar-graphic (3)
.BR akfavatar-term (3)
.BR akfavatar.utf8 (3)
.br
.B http://lua.coders-online.net/
.br
.B http://www.lua.org/manual/5.2/
.br
.B http://akfavatar.nongnu.org/manual/
